#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('Exchange:server');
var http = require('http');
var amqp = require('amqplib/callback_api');
var mysql = require('mysql');
var Fix = require('../node_modules/fix/fix.js');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3001');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

//Order generation variables
var symbols = ["LN" , "NN" , "NP" , "HH" , "ON" , "HP" ,
  "PD" , "HB" , "TC" , "PH" , "NR" , "TR" , "NL" , "5Z" ,
  "GL" , "PG" , "IN" , "NH" , "9F" , "NW" , "G4" , "PW" ,
  "CI" , "6J" , "NX" , "NK" , "CZ" , "NJ" , "ZR" , "E7" , 
  "AB"]; 

var Milliseconds1Day = 24 * 60 * 60 * 1000;
var Milliseconds30Days = 30 * Milliseconds1Day;
var period = (2 * Math.PI) / (Milliseconds30Days); // Period is 30 days in milliseconds

var shift = [93.12, 24.42, 32.24, 6.75, 90.37, 57.49, 
            32.46, 76.14, 95.56, 54.76, 54.4, 73.72, 94.37, 
            76.62, 12.92, 40.61, 56.78, 36.58, 49.19, 35.53,
            22.89, 14.81, 37.29, 48.41, 81.13, 7.33, 66.7,
            65.36, 93.21, 34.5, 92.32, 47.56, 68.73]

var amp = [11.34, 18.89, 27.63, 5.05, 68.66, 38.71, 22.75,
          70.93, 45.05, 10.4, 31.72, 23.61, 26.92, 53.05, 
          10.04, 37.12, 25.21, 8.68, 43.7, 28.24, 21.33, 14.23,
          6.62, 45.33, 80.17, 6.47, 63.68, 39.11, 47.87, 12.05,
          91.01, 19.18, 44.57]
var d = new Date();

//Database variables
var databaseIP = "104.131.22.150";
var databaseUser = "rrp";
var databasePass = "rrp";
var database = "financial";
var connection = mysql.createConnection(
  {
    host     : databaseIP,
    user     : databaseUser,
    password : databasePass,
    database : database,
  }
);

connection.connect();
//Constraints on Generated Orders
var constraints = null;

/* Returns random values in a normal distribution 
using an inverse erf for normal function
@return - random number between 0 and 1 */
function inverse_erf(lower_bound, upper_bound){
  random = Math.random();
  var range = upper_bound - lower_bound;
  random = (random * range) + lower_bound;
  term1 = random;
  console.log("random number generated: "+random);
  term2 = (Math.PI / 12) * Math.pow(random, 3);
  term3 = ((7 * Math.pow(Math.PI, 2)) / 480) * Math.pow(random, 5);
  term4 = ((127 * Math.pow(Math.PI, 3)) / 40320) * Math.pow(random, 7);
  term5 = ((4369 * Math.pow(Math.PI, 4)) / 5806080) * Math.pow(random, 9);
  multiplier = 0.5 * Math.sqrt(Math.PI);
  return multiplier * (term1  + term2 + term3 + term4 + term5);
}

/* Generate a random order with the given information
@param symbol - symbol of the stock
@param time - time the order should be made
@param isBuy - if the stock is a buy or sell */
function generateOrder(symbol, time, isBuy, isFuture){
  console.log("isBuy: "+isBuy);
  //generate random number of lots between 1 and 1001
  var lots = Math.round((Math.random() * 1000) + 1);
  //get the value of the symbol according to its sin wave
  symbol_index = symbols.indexOf(symbol);
  symbol_shift = shift[symbol_index];
  symbol_amp = amp[symbol_index];
  var mean = getMarketPrice(symbol, time);
  console.log("mean");
  console.log(mean);
  //Generate a random number with a normal distribution
  //Multiple by variance and shift by mean
  var price;
  if (!isFuture){
    if (isBuy){
      price = inverse_erf(0, 1);
    }
    else{
      price = inverse_erf(-1, 0);
    }
    price = (price * 5) + mean;
  }
  else{
    if (isBuy){
      price = inverse_erf(-0.5, 1);
    }
    else{
      price = inverse_erf(-1, 0.5);
    }
    price = (price * 5) + mean;
  }
  price = +(price.toFixed(2));
  console.log([lots, price]);
  return [lots, price];
}

function getMarketPrice(symbol, time) {
  var symbol_index = symbols.indexOf(symbol);
  var symbol_shift = shift[symbol_index];
  var symbol_amp = amp[symbol_index];
  var mean = symbol_amp * Math.sin(period * time) + symbol_shift;
  return mean;
}

/* Returns a list of fills represented by triples
where each triple is (lots, price, time)
@param symbol - symbol of stock to generate orers for
@param price - price of stock to buy/sell
@param lots - number of lots to buy/sell
@param isBuy - if the order to generate fills for is a buy or sell
*/
function fillOrder(message){
  var symbol = Fix.read(message).Symbol;
  var price = parseInt(Fix.read(message).Price);
  var lots = parseInt(Fix.read(message).OrderQty);
  console.log('Ronas isBuy' + Fix.read(message).Side);
  var isBuy = Fix.read(message).Side == "Buy";
  console.log
  var expiry = Fix.read(message).MaturityMonthYear;
  var myUid = Fix.read(message).OrderID;
  var type = Fix.read(message).OrdType;
  var filled = false;
  var fills = [];

  var num = 0;
  //Generate 10 orders from the last minute
  var currentTime = d.getTime();
  if (type == '1'){
    price = getMarketPrice(symbol, currentTime);
  }
  else if (type == 'P'){
    price = getMarketPrice(symbol, currentTime);
  }
  for(var i = 1; i < 11 && lots > 0; i++){
    num++;
    var time = currentTime - (60000 / 10) * i;
    var generated_order = generateOrder(symbol, time, isBuy, false);
    var fill = checkForFill(symbol, price, lots, isBuy, generated_order)
    if (fill && satisfiesConstraints(fill[1], time, isBuy))
    {
      console.log("fill1");
      console.log(fill);
      fill.push(time);
      fills.push(fill);
      console.log(fills);
      lots -= fill[0];
    }
  }
  //Generated 50 orders from now to the next 30 days
  for (var i = 0; i < 50 && lots > 0; i++){
    num++;
    var time = currentTime + (Milliseconds30Days / 50) * i;
    var generated_order = generateOrder(symbol, time, isBuy, true);
    if (type == 'P'){
      price = getMarketPrice(symbol, time);
      console.log("Rona")
    }
    var fill = checkForFill(symbol, price, lots, isBuy, generated_order);
    if (fill && satisfiesConstraints(fill[1], time, isBuy))
    {  
      console.log("fill2");
      console.log(fill);    
      fill.push(time);
      fills.push(fill);
      console.log(fills);
      lots -= fill[0];
    }
    //If a fill was found, generate 10 orders from the next minute 
    //after the fill or if it's a market/pegged, b/c it's likely to be filled
    if ((fill && satisfiesConstraints(fill[1], time, isBuy)) || type != '2'){
      for (var j = 0; j < 10 && lots > 0; j++)
      {
        num++;
        var inner_time = time + (60000 / 10) * j;
        var generated_order = generateOrder(symbol, inner_time, isBuy, true);
        if (type == 'P'){
          price = getMarketPrice(symbol, time);
        }
        var inner_fill = checkForFill(symbol, price, lots, isBuy, generated_order);
        if (inner_fill && satisfiesConstraints(inner_fill[1], inner_time, isBuy)){
            console.log("fill3");
            console.log(fill);    
            inner_fill.push(inner_time)      
            fills.push(inner_fill);
            console.log(fills);
            lots -= inner_fill[0];
        }    
      } 
    }
  }
  //Add the constraint that this offer makes on future offers
  addNewConstraint(symbol, isBuy, fills, expiry);
  console.log(num);
  var largest_trans_time = 0;
  for (i = 0; i < fills.length; i++) {
    if (fills[i][2] > largest_trans_time ){
      largest_trans_time = fills[i][2];
    }
  }
  var last_fix;
  // Create FIX for each fill
  for (i = 0; i < fills.length; i++) {
    (function(i) {
      fillslots = fills[i][0]
      price = fills[i][1]
      transacttime= fills[i][2]
      ordstatus = 1; 
      if (transacttime == largest_trans_time) {
        console.log("transact time and largest time comparison");
        if (lots == 0) {
          ordstatus = 2;
        }
        else {
          ordstatus = 3; 
        }
      }
      console.log(myUid);
      var fill_fix_message = Fix.message({
        OrderQty: fillslots,
        Price: price,
        TransactTime: transacttime,
        OrdStatus: ordstatus
      }, true);

      if (transacttime != largest_trans_time) {
        setTimeout(function() {sendReply(fill_fix_message, myUid)},250);
      } 
      else {
        last_fix = fill_fix_message;
        console.log("HERE", last_fix);
      }
    })(i);
  }
  console.log("meow", last_fix);
  if (!last_fix){
    last_fix = Fix.message({
      OrderQty: 0,
      Price: 0,
      TransactTime: d.getTime(),
      OrdStatus: 3
    }, true);
  }
  setTimeout(function() {sendReply(last_fix, myUid)}, 250);
  return fills;
}

/*
Finds the new constraint this trades's fills makes
on future offers and adds it to the database
@param symbol - symbol of the offer being filled
@param isBuy - if the trade was a buy or fill
@param fills - the fills that are filling this trade
*/
function addNewConstraint(symbol, isBuy, fills, expiry){
  //Look for the most extreme price at the latest date
  //Make that the contraints
  if (fills.length > 0)
  {
    var largest_price = fills[0][1]
    var largest_time = fills[0][2]
    for (fill in fills)
    {
      fill = fills[fill]
      if (isBuy){
        if (fill[1] > largest_price){
          largest_price = fill[1];
        }
      }
      else{
        if (fill[1] < largest_price){
          largest_price = fill[1];
        }  
      }
      if (fill[2] > largest_time){
        largest_time = fill[2];
      }
    }
  }
  //Add to database
  addConstraint(symbol, largest_price, largest_time, isBuy, expiry);
}

/* Check if the fill satisfies contraints from
previous trades
@price - price of the new fill
@time - time of the new fill 
@return - true if the fill satisfies contraints, 
otherwise false*/
function satisfiesConstraints(price, time, isBuy){
  var satisfies = true;
  for (constraint in constraints){
    constraint = constraints[constraint]
    if (time < constraint.time){
      if (isBuy && price < constraint.price){
        console.log("breaks constraints");
        satisfies = false;
        break;
      }
      else if (!isBuy && price < constraint.price){
        console.log("breaks constraint");
        satisfies = false;
        break;
      }
      break;
    }
  }
  return satisfies;  
}

/* Check if the order generated can be a fill for this trade
@param symbol - stock symbol of the trade
@param price - price of the trade
@param lots - number of lots to buy/sell in the trade
@param isBuy - if the trade is a buy or sell
@param generated_order - random generated market order
@return  - returns the fill or null if not valid */
function checkForFill(symbol, price, lots, isBuy, generated_order){
  var generated_lots = generated_order[0];
  var generated_price = generated_order[1];
  if ((isBuy && generated_price <= price) || (!isBuy && generated_price >= price)){
    if (generated_lots > lots){
      return [lots, price];
    }
    else{
      return [generated_lots, price];
    }
  }
  console.log("breaks price");
  return null
}

var constraints;

/* Get the contraints from previous filled trades from 
the database, then fill the trade in the callback
@param symbol - symbol of the next trade to fill
@param price - price of the next trade to fill
@param lots - number of lots of the next trade
@param isBuy - if the next trade is a buy or sell */
function getConstraints(message){
  var symbol = Fix.read(message).Symbol;
  var price = parseInt(Fix.read(message).Price);
  var lots = parseInt(Fix.read(message).OrderQty);
  var isBuy = Fix.read(message).Side == "Buy"
  var expiry = Fix.read(message).MaturityMonthYear;
  var myUid = Fix.read(message).OrderID;
  var queryString = "Select price, time FROM Constraints WHERE isBuy='" + 
    isBuy + "' and symbol='" + symbol + "' and expiry='" + expiry + "';";

  connection.query(queryString, function(err, rows, fields) {
    if (err) throw err;
    console.log("Got Constraints");
    constraints = rows;
    console.log(constraints);
    var result = fillOrder(message);
    console.log(result);
    return result;
  });
}


/* Add the new contraint to the database 
and removes outdated contraints in the callback
@param symbol - symbol of the new contraint
@param price  - price of the new contraint
@param time - time of the new contraint
@param isBuy - if the contraint was a sell/buy
*/
function addConstraint(symbol, price, time, isBuy, expiry){
  var queryString = "INSERT INTO Constraints VALUES ('" + symbol + "','" + price + "','" + time + "','" 
    + isBuy + "','" + expiry + "');";

  connection.query(queryString, function(err, rows, fields) {
    if (err) throw err;
    console.log("Added Constraints");
    removeConstraints();
  });
}

/* Removes outdated contraints from the database
and processes the next trade in the callback*/
function removeConstraints(){
  var queryString = "DELETE FROM Constraints WHERE time < " + (d.getTime() - 60000) + ";"
  connection.query(queryString, function(err, rows, fields) {
    if (err) throw err;
    console.log("Removed Constraints");    
    if (recieved_trades.length > 0){
      var next_task = recieved_trades.pop();
      processTrade(next_task);
    }
    else{
      isWorking = false;
    }
  }); 
}

function processTrade(message){
  isWorking = true;
          
  getConstraints(message);
}

//Set up listening on MoM
var recieved_trades = []
var isWorking = false;
amqp.connect('amqp://test:test@104.131.22.150/', function(err, conn) {
  conn.createChannel(function(err, ch) {
    var q = 'Exchange';

    ch.assertQueue(q, {durable: false});
    console.log(" [*] Waiting for messages in %s. To exit press CTRL+C", q);
    ch.consume(q, function(msg) {
      //Process messages
      ch.ack(msg);
      var message = String(msg.content.toString());
      console.log(" [x] Received %s", message);
      if(message.indexOf("MARKETPRICE: ") === -1) {
				console.log(Fix.read(message).OrderID);


				//Compose reply
				// var myUid = message.split(": ")[1];
				// console.log(myUid);

				// Get 
        if (!isWorking){
          processTrade(message);
        }
        else{
          recieved_trades.push(message);
        }
  
      }
      else {
        //market price request
        var symbol = message.substring(13);
        var price = getMarketPrice(symbol, d.getTime());
        setTimeout(function() {sendMarketPrice(price, symbol)},250);;
      }
    }, {noAck: false});
  });
});

function sendMarketPrice(price, topic) {
  amqp.connect('amqp://test:test@104.131.22.150/', function(err, conn) {
    conn.createChannel(function(err, ch) {
      var ex = 'MarketPrice';
      var p = String(price);
      ch.assertExchange(ex, 'topic', {durable: true});
      ch.publish(ex, topic, new Buffer(p));
      console.log(" [x] Sent %s:'%s'", topic, price);
    });

    setTimeout(function() { conn.close(); }, 500);
  });
}

function sendReply(reply, topic)
{
  amqp.connect('amqp://test:test@104.131.22.150/', function(err, conn) {
    conn.createChannel(function(err, ch) {
      var ex = 'Fill';

      ch.assertExchange(ex, 'topic', {durable: true});
      ch.publish(ex, topic, new Buffer(reply));
      console.log(" [x] Sent %s:'%s'", topic, reply);
    });

    setTimeout(function() { conn.close(); }, 500);
  });
}

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
 
exports.recieved_trades = recieved_trades;
