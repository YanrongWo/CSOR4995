#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('Exchange:server');
var http = require('http');
var amqp = require('amqplib/callback_api');
var mysql = require('mysql');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3001');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

//Order generation variables
var symbols = ["LN" , "NN" , "NP" , "HH" , "ON" , "HP" ,
  "PD" , "HB" , "TC" , "PH" , "NR" , "TR" , "NL" , "5Z" ,
  "GL" , "PG" , "IN" , "NH" , "9F" , "NW" , "G4" , "PW" ,
  "CI" , "6J" , "NX" , "NK" , "CZ" , "NJ" , "ZR" , "E7" , 
  "AB" , "AB" , "AB"]; 

var Milliseconds1Day = 24 * 60 * 60 * 1000;
var Milliseconds30Days = 30 * Milliseconds1Day;
var period = (2 * Math.PI) / (Milliseconds30Days); // Period is 30 days in milliseconds

var shift = [93.12, 24.42, 32.24, 6.75, 90.37, 57.49, 
            32.46, 76.14, 95.56, 54.76, 54.4, 73.72, 94.37, 
            76.62, 12.92, 40.61, 56.78, 36.58, 49.19, 35.53,
            22.89, 14.81, 37.29, 48.41, 81.13, 7.33, 66.7,
            65.36, 93.21, 34.5, 92.32, 47.56, 68.73]

var amp = [11.34, 18.89, 27.63, 5.05, 68.66, 38.71, 22.75,
          70.93, 45.05, 10.4, 31.72, 23.61, 26.92, 53.05, 
          10.04, 37.12, 25.21, 8.68, 43.7, 28.24, 21.33, 14.23,
          6.62, 45.33, 80.17, 6.47, 63.68, 39.11, 47.87, 12.05,
          91.01, 19.18, 44.57]
var d = new Date();

//Database variables
var databaseIP = "104.131.22.150";
var databaseUser = "rrp";
var databasePass = "rrp";
var database = "financial";
var connection = mysql.createConnection(
  {
    host     : databaseIP,
    user     : databaseUser,
    password : databasePass,
    database : database,
  }
);

connection.connect();
//Constraints on Generated Orders
var constraints = null;

/* Returns random values in a normal distribution 
using an inverse erf for normal function
@return - random number between 0 and 1 */
function inverse_erf(lower_bound, upper_bound){
  random = Math.random();
  var range = upper_bound - lower_bound;
  random = (random * range) + lower_bound;
  term1 = random;
  term2 = (Math.PI / 12) * Math.pow(random, 3);
  term3 = ((7 * Math.pow(Math.PI, 2)) / 480) * Math.pow(random, 5);
  term4 = ((127 * Math.pow(Math.PI, 3)) / 40320) * Math.pow(random, 7);
  term5 = ((4369 * Math.pow(Math.PI, 4)) / 5806080) * Math.pow(random, 9);
  multiplier = 0.5 * Math.sqrt(Math.PI);
  return multiplier * (term1  + term2 + term3 + term4 + term5);
}

/* Generate a random order with the given information
@param symbol - symbol of the stock
@param time - time the order should be made
@param isBuy - if the stock is a buy or sell */
function generateOrder(symbol, time, isBuy, isFuture){
  //generate random number of lots between 1 and 1001
  var lots = Math.round((Math.random() * 1000) + 1);
  //get the value of the symbol according to its sin wave
  symbol_index = symbols.indexOf(symbol);
  symbol_shift = shift[symbol_index];
  symbol_amp = amp[symbol_index];
  mean = symbol_amp * Math.sin(period * time) + symbol_shift;
  console.log("mean");
  console.log(mean);
  //Generate a random number with a normal distribution
  //Multiple by variance and shift by mean
  var price;
  if (!isFuture){
    if (isBuy){
      price = inverse_erf(-1, 0);
    }
    else{
      price = inverse_erf(0, 1);
    }
    price = (price * 5) + mean;
  }
  else{
    if (isBuy){
      price = inverse_erf(-1, 0.1);
    }
    else{
      price = inverse_erf(-0.1, 1);
    }
    price = (price * 5) + mean;
  }
  price = +(price.toFixed(2));
  console.log("generated");
  console.log([lots, price]);
  return [lots, price];
}

/* Returns a list of fills represented by triples
where each triple is (lots, price, time)
@param symbol - symbol of stock to generate orers for
@param price - price of stock to buy/sell
@param lots - number of lots to buy/sell
@param isBuy - if the order to generate fills for is a buy or sell
*/
function fillOrder(symbol, price, lots, isBuy){
  var filled = false;
  var fills = []

  //Generate 10 orders from the last minute
  var currentTime = d.getTime();
  for(var i = 1; i < 11 && lots > 0; i++){
    var time = currentTime - (60000 / 10) * i;
    var generated_order = generateOrder(symbol, time, !isBuy, false);
    var fill = checkForFill(symbol, price, lots, isBuy, generated_order)
    if (fill && satisfiesConstraints(fill[1], time))
    {
      console.log("fill1");
      console.log(fill);
      fill.push(time);
      fills.push(fill);
      console.log(fills);
      lots -= fill[0];
    }
  }
  //Generated 50 orders from now to the next 30 days
  for (var i = 0; i < 50 && lots > 0; i++){
    var time = currentTime + (Milliseconds30Days / 50) * i;
    var generated_order = generateOrder(symbol, time, !isBuy, true);
    var fill = checkForFill(symbol, price, lots, isBuy, generated_order)
    if (fill && satisfiesConstraints(fill[1], time))
    {  
      console.log("fill2");
      console.log(fill);    
      fill.push(time);
      fills.push(fill);
      console.log(fills);
      lots -= fill[0];
      //If a fill was found, generate 10 orders from the next minute 
      //after the fill
      for (var j = 0; j < 10 && lots > 0; j++)
      {
        var inner_time = time + (60000 / 10) * j;
        var generated_order = generateOrder(symbol, inner_time, !isBuy, true);
        var inner_fill = checkForFill(symbol, price, lots, isBuy, generated_order)
        if (inner_fill && satisfiesConstraints(inner_fill[1], inner_time)){
            console.log("fill3");
            console.log(fill);    
            inner_fill.push(inner_time)      
            fills.push(inner_fill);
            console.log(fills);
            lots -= inner_fill[0];
        }    
      } 
    }
  }
  addNewConstraint(symbol, isBuy, fills);
  return fills;
}


function addNewConstraint(symbol, isBuy, fills){
  if (fills.length > 0)
  {
    var largest_price = fills[0][1]
    var largest_time = fills[0][2]
    for (fill in fills)
    {
      fill = fills[fill]
      if (fill[1] > largest_price){
        largest_price = fill[1];
      }
      if (fill[2] > largest_time){
        largest_time = fill[2];
      }
    }
  }
  console.log("new constraint");
  console.log(largest_price);
  console.log(largest_time);
  addConstraint(symbol, largest_price, largest_time, isBuy);
}

function satisfiesConstraints(price, time){
  var satisfies = true;
  for (constraint in constraints){
    constraint = constraints[constraint]
    if (time < constraint.time && price < constraint.price){
      console.log("breaks constraints");
      satisfies = false;
      break;
    }
  }
  return satisfies;  
}

function checkForFill(symbol, price, lots, isBuy, generated_order){
  var generated_lots = generated_order[0];
  var generated_price = generated_order[1];
  if ((isBuy && generated_price <= price) || (!isBuy && generated_price >= price)){
    if (generated_lots > lots){
      return [lots, price];
    }
    else{
      return [generated_lots, price];
    }
  }
  console.log("breaks price");
  return null
}

var constraints;

function getConstraints(symbol, price, lots, isBuy){

  var queryString = "Select price, time FROM Constraints WHERE isBuy='" + isBuy + "' and symbol='" + symbol + "'";

  connection.query(queryString, function(err, rows, fields) {
    if (err) throw err;
    console.log("here!");
    constraints = rows;
    var result = fillOrder(symbol, price, lots, isBuy);
    console.log(result);
  });
}

console.log(getConstraints("LN", 93.30, 3, true));
connection.end();

function addConstraint(symbol, price, time, isBuy){
  var queryString = "INSERT INTO Constraints VALUES ('" + symbol + "','" + price + "','" + time + "','" + isBuy + "');";

  connection.query(queryString, function(err, rows, fields) {
    if (err) throw err;
    removeConstraints();
  });
}

function removeConstraints(){
  var queryString = "DELETE FROM Constraints WHERE time < " + (d.getTime() - 60000) + ";"
  connection.query(queryString, function(err, rows, fields) {
    if (err) throw err;
    //var next_task = recieved_trades.pop()
    //getConstraints(next_task.symbol, next_task.price, next_task.lots, next_task.isBuy);
  }); 
}

/*//Set up listening on MoM
var recieved_trades = []

amqp.connect('amqp://test:test@104.131.22.150/', function(err, conn) {
  conn.createChannel(function(err, ch) {
    var q = 'Exchange';

    ch.assertQueue(q, {durable: false});
    console.log(" [*] Waiting for messages in %s. To exit press CTRL+C", q);
    ch.consume(q, function(msg) {
      //Process messages
      ch.ack(msg);
      var message = String(msg.content.toString());
      recieved_trades.push(message);
      console.log(" [x] Received %s", message);

      //Compose reply
      var myUid = message.split(": ")[1];
      console.log(myUid);
      var reply = "FIX filled message reply - finished";
      setTimeout(function() {sendReply(reply, myUid)},250);;        
    }, {noAck: false});
  });
});

function sendReply(reply, topic)
{
  amqp.connect('amqp://test:test@104.131.22.150/', function(err, conn) {
    conn.createChannel(function(err, ch) {
      var ex = 'Fill';

      ch.assertExchange(ex, 'topic', {durable: true});
      ch.publish(ex, topic, new Buffer(reply));
      console.log(" [x] Sent %s:'%s'", topic, reply);
    });

    setTimeout(function() { conn.close(); }, 500);
  });
}*/

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
//Rona 
//exports.recieved_trades = recieved_trades;